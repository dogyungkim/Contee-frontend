---
description: Use when task is related to OAuth, Auth API
alwaysApply: false
---
# Contee Backend - 인증 API 문서

## 개요
Contee 백엔드의 인증 관련 API 엔드포인트들을 정리한 문서입니다.  
JWT 기반 인증과 OAuth2 (Google) 로그인을 지원합니다.

## Base URL
- **개발 환경**: `http://localhost:8080`
- **프로덕션 환경**: `https://api.contee.com` (예정)

## 공통 응답 형식

### 성공 응답
```json
{
  "success": true,
  "message": "Success message",
  "data": { ... }
}
```

### 에러 응답
```json
{
  "success": false,
  "message": "Error message",
  "data": null
}
```

---

## 1. OAuth2 로그인

### 1.1 Google OAuth2 로그인 시작
**엔드포인트**: `GET /oauth2/authorization/google`

**설명**: Google OAuth2 로그인을 시작합니다. 사용자를 Google 로그인 페이지로 리다이렉트합니다.

**Usage**:
- 직접 API 호출을 하는 것이 아닌 백엔드 서버에 모든 권한을 위임하고 사용자를 Google 로그인 페이지로 리다이렉트합니다.
```typescript
window.location.href = 'http://localhost:8080/oauth2/authorization/google';
```

---

### 1.2 OAuth2 콜백 처리
**엔드포인트**: `GET /login/oauth2/code/google`

**설명**: Google OAuth2 인증 완료 후 콜백을 처리합니다. JWT 토큰을 생성하고 프론트엔드로 리다이렉트합니다.

**Request**:
- **Method**: GET
- **Headers**: 없음 (리다이렉트)
- **Query Parameters**:
  - `code`: Google에서 발급한 인증 코드
  - `state`: CSRF 보호를 위한 상태 값 (선택사항)

**Usage**:
- 서버가 refresh token을 쿠키에 저장하고 프론트엔드로 리다이렉트합니다.
- callback 페이지에서 refreshToken을 활용하여 access token을 발급받습니다.

**Response**:
- **Status**: 302 Found
- **Headers**: 
  - `Location: http://localhost:3000/auth/callback`
  - `Set-Cookie: refreshToken=...; HttpOnly; Secure; SameSite=None`
- **Body**: 없음 (리다이렉트)

**에러 케이스**:
- **Status**: 302 Found
- **Headers**: `Location: http://localhost:3000/auth/callback?success=false&error=authentication_failed&message=...`
- **설명**: 인증 실패 시 에러 파라미터와 함께 리다이렉트

---

## 2. JWT 토큰 관리

### 2.1 토큰 갱신
**엔드포인트**: `POST /api/v1/auth/refresh`

**설명**: Refresh Token을 사용하여 새로운 Access Token을 발급합니다.

**Request**:
- **Method**: POST
- **Headers**: 없음
- **Body**: 없음
- **Cookies**: `refreshToken` (HttpOnly)

**Response**:
- **Status**: 200 OK
- **Body**:
```json
{
  "success": true,
  "message": "Token refreshed successfully",
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "user": {
      "id": 1,
      "email": "user@example.com",
      "name": "홍길동",
      "profileImageUrl": "https://example.com/profile.jpg",
      "provider": "google"
    }
  }
}
```

**에러 케이스**:
- **Status**: 400 Bad Request
- **Body**:
```json
{
  "success": false,
  "message": "Refresh token not found in cookie",
  "data": null
}
```

- **Status**: 400 Bad Request
- **Body**:
```json
{
  "success": false,
  "message": "Invalid refresh token",
  "data": null
}
```

---

### 2.2 현재 사용자 정보 조회
**엔드포인트**: `GET /api/v1/auth/me`

**설명**: 현재 인증된 사용자의 정보를 조회합니다.

**Request**:
- **Method**: GET
- **Headers**: 
  - `Authorization: Bearer {accessToken}`
- **Body**: 없음

**Response**:
- **Status**: 200 OK
- **Body**:
```json
{
  "success": true,
  "message": "User info retrieved successfully",
  "data": {
    "id": 1,
    "email": "user@example.com",
    "name": "홍길동",
    "profileImageUrl": "https://example.com/profile.jpg"
  }
}
```

**에러 케이스**:
- **Status**: 401 Unauthorized
- **Body**:
```json
{
  "success": false,
  "message": "Unauthorized",
  "data": null
}
```

- **Status**: 400 Bad Request
- **Body**:
```json
{
  "success": false,
  "message": "Failed to get user info: ...",
  "data": null
}
```

---

### 2.3 로그아웃
**엔드포인트**: `POST /api/v1/auth/logout`

**설명**: 사용자를 로그아웃 처리하고 Refresh Token 쿠키를 삭제합니다.

**Request**:
- **Method**: POST
- **Headers**: 
  - `Authorization: Bearer {accessToken}` (선택사항)
- **Body**: 없음

**Response**:
- **Status**: 200 OK
- **Headers**: `Set-Cookie: refreshToken=; Max-Age=0; HttpOnly; Secure; SameSite=None`
- **Body**:
```json
{
  "success": true,
  "message": "Logout successful",
  "data": null
}
```

**에러 케이스**:
- **Status**: 400 Bad Request
- **Body**:
```json
{
  "success": false,
  "message": "Logout failed: ...",
  "data": null
}
```

---

## 3. 데이터 모델

### 3.1 AuthResponse
```typescript
interface AuthResponse {
  accessToken: string;
  user: {
    id: number;
    email: string;
    name: string;
    profileImageUrl: string;
    provider: string;
  };
}
```

### 3.2 UserResponse
```typescript
interface UserResponse {
  id: number;
  email: string;
  name: string;
  profileImageUrl: string;
}
```

---

## 4. 인증 플로우

### 4.1 OAuth2 로그인 플로우
```mermaid
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant B as Backend
    participant G as Google

    U->>F: "Google 로그인" 클릭 (하이퍼링크)
    F->>B: GET /oauth2/authorization/google (브라우저 리다이렉트)
    B->>G: Google OAuth2 인증 페이지로 리다이렉트
    U->>G: Google 계정으로 로그인
    G->>B: GET /login/oauth2/code/google?code=...
    B->>B: JWT 토큰 생성
    B->>F: 리다이렉트 + Refresh Token 쿠키 설정
    Note over F: 콜백 페이지에서 토큰 갱신
    F->>B: POST /api/v1/auth/refresh (토큰 갱신)
    B->>F: Access Token 반환
```

### 4.2 토큰 갱신 플로우
```mermaid
sequenceDiagram
    participant F as Frontend
    participant B as Backend

    F->>B: POST /api/v1/auth/refresh (Refresh Token 쿠키)
    B->>B: Refresh Token 검증
    B->>B: 새로운 Access Token 생성
    B->>F: 새로운 Access Token 반환
```

---

## 5. 보안 고려사항

### 5.1 토큰 관리
- **Access Token**: 15분 만료, Authorization 헤더로 전송
- **Refresh Token**: 7일 만료, HttpOnly 쿠키로 전송
- **토큰 갱신**: Access Token 만료 전 자동 갱신 권장

### 5.2 CORS 설정
- **허용된 오리진**: `http://localhost:3000`, `http://127.0.0.1:3000`
- **허용된 메서드**: GET, POST, PUT, DELETE, OPTIONS, PATCH
- **허용된 헤더**: 모든 헤더
- **쿠키 지원**: `credentials: true`

### 5.3 쿠키 설정
- **HttpOnly**: true (XSS 공격 방지)
- **Secure**: true (HTTPS에서만 전송)
- **SameSite**: None (크로스 사이트 요청 허용)

---

## 6. 에러 코드 참조

| HTTP Status | 에러 메시지 | 설명 |
|-------------|-------------|------|
| 200 | Success | 요청 성공 |
| 400 | Bad Request | 잘못된 요청 (토큰 없음, 유효하지 않은 토큰 등) |
| 401 | Unauthorized | 인증 실패 |
| 500 | Internal Server Error | 서버 내부 오류 |

---

## 7. 프론트엔드 구현 가이드

### 7.1 OAuth2 로그인 구현

#### 7.1.1 JavaScript 리다이렉트 방식
```javascript
// Google 로그인 시작 (페이지 리다이렉트)
const handleGoogleLogin = () => {
  window.location.href = 'http://localhost:8080/oauth2/authorization/google';
};

// 또는 새 창에서 열기
const handleGoogleLoginNewWindow = () => {
  window.open('http://localhost:8080/oauth2/authorization/google', '_blank');
};
```

### 7.2 토큰 갱신 구현
```javascript
const refreshToken = async () => {
  try {
    const response = await fetch('http://localhost:8080/api/v1/auth/refresh', {
      method: 'POST',
      credentials: 'include', // 쿠키 포함
    });
    
    const data = await response.json();
    
    if (data.success) {
      localStorage.setItem('accessToken', data.data.accessToken);
      // 사용자 정보 저장
      setUser(data.data.user);
    } else {
      // 로그인 페이지로 리다이렉트
      window.location.href = '/login';
    }
  } catch (error) {
    console.error('Token refresh failed:', error);
  }
};
```

### 7.3 API 요청 시 토큰 사용
```javascript
const apiRequest = async (url, options = {}) => {
  const token = localStorage.getItem('accessToken');
  
  const response = await fetch(url, {
    ...options,
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json',
      ...options.headers,
    },
    credentials: 'include',
  });
  
  // 401 에러 시 토큰 갱신 시도
  if (response.status === 401) {
    await refreshToken();
    // 재시도
    return apiRequest(url, options);
  }
  
  return response;
};
```

---

## 8. 주의사항

1. **HTTPS 사용**: 프로덕션 환경에서는 반드시 HTTPS를 사용해야 합니다.
2. **OAuth2 로그인**: 프론트엔드에서 OAuth2 로그인은 `window.location.href`로 처리해야 합니다. AJAX/fetch로 직접 호출하면 안 됩니다.
3. **토큰 보안**: Access Token은 localStorage에 저장, Refresh Token은 HttpOnly Cookie로 저장합니다.
4. **콜백 페이지**: OAuth2 콜백을 처리할 전용 페이지(`/auth/callback`)를 준비해야 합니다.
